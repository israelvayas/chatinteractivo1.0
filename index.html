<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat con Control de Historial y Moderación</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga de Tone.js para la generación de sonido en tiempo real -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Configuración de la fuente Inter y estilos base */
        body { font-family: 'Inter', sans-serif; }
        
        #drawingCanvas {
            border: 2px solid #3b82f6;
            background-color: #ffffff;
            touch-action: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #chatMessages, #chat-list-view {
            height: 65vh; 
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .system-message {
            background-color: #e0f2fe;
            padding: 8px 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            font-style: italic;
            text-align: center;
        }
        
        #colorPicker {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 3rem; height: 2.5rem; background: none; border: none; cursor: pointer;
        }
        #colorPicker::-webkit-color-swatch { border-radius: 6px; border: 2px solid #ccc; }
        #colorPicker::-moz-color-swatch { border-radius: 6px; border: 2px solid #ccc; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">

    <!-- Contenedor central y compacto -->
    <div class="max-w-lg mx-auto bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col h-full">

        <!-- Encabezado Fijo -->
        <div id="main-header">
            <h2 class="text-xl font-bold p-4 bg-indigo-600 text-white rounded-t-xl text-center">
                💬 Chat Interactivo
            </h2>
            <div class="bg-indigo-50 text-indigo-800 text-xs p-2 text-center break-words flex flex-col items-center gap-1">
                <div id="userInfo" class="font-medium">Cargando conexión y perfil...</div>
                <div id="usernameSetup" class="flex flex-col items-center w-full max-w-sm mx-auto p-2 bg-white rounded-lg shadow-inner border border-indigo-200 hidden">
                    <p id="usernameError" class="text-red-600 text-xs mb-1 hidden"></p>
                    <div class="flex w-full">
                        <input type="text" id="usernameInput" placeholder="Elige tu nombre (ej: Ana87)" maxlength="15" class="flex-grow p-1 border border-gray-300 rounded-l-md focus:ring-2 focus:ring-indigo-500 text-gray-800 text-sm">
                        <button onclick="attemptSetUsername()" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1 px-2 text-sm rounded-r-md transition duration-150">Guardar</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Tu ID: <span id="userIdShort">...</span></p>
                </div>
                <button id="usernameDisplay" onclick="showUsernameSetup()" class="text-sm font-bold p-1 bg-indigo-200 hover:bg-indigo-300 rounded-lg px-3 transition duration-150 hidden cursor-pointer"></button>
            </div>
        </div>

        <!-- Contenedor principal que aloja las dos vistas -->
        <div class="flex flex-col flex-grow">
            <!-- Vista 1: Lista de Chats (Estilo WhatsApp) -->
            <div id="chat-list-view" class="p-2 border-t">
                <!-- El contenido se genera dinámicamente -->
            </div>

            <!-- Vista 2: Conversación de Chat Activa -->
            <div id="chat-messages-view" class="hidden flex flex-col h-full">
                <!-- Cabecera del chat con botón de volver -->
                <div class="flex items-center p-2 bg-gray-100 border-b border-t">
                    <button onclick="showChatList()" class="p-2 rounded-full hover:bg-gray-200 mr-2 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <h3 id="currentChatTitle" class="font-bold text-gray-800 text-lg"></h3>
                </div>

                <!-- Área de Mensajes -->
                <div id="chatMessages" class="p-4 flex-grow"></div>

                <!-- Controles de Input, Dibujo y Sonido -->
                <div id="input-controls" class="p-4 border-t border-gray-200">
                    
                    <!-- Nueva barra de entrada unificada (Alerta, Mensaje, Enviar) -->
                    <div class="flex gap-2 items-center mb-4">
                        <!-- Botón de Alerta Contextual -->
                        <button onclick="sendContextualAlert()" id="contextualAlertBtn" class="flex-shrink-0 w-12 h-12 flex items-center justify-center bg-red-500 hover:bg-red-600 text-white text-xl rounded-xl shadow-lg transition duration-150 transform hover:scale-105" title="Enviar Alerta Sonora">🚨</button>
                        
                        <!-- Input de Mensaje -->
                        <input type="text" id="messageInput" placeholder="Escribe tu mensaje..." class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-indigo-500">
                        <button onclick="sendChatMessage()" class="flex-shrink-0 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-xl transition duration-150">Enviar</button>
                    </div>

                    <div class="mb-4">
                        <button onclick="toggleDrawingArea()" id="toggleDrawingBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 rounded-lg transition duration-150">✍️ Abrir Pizarra de Dibujo</button>
                    </div>
                    <div id="drawingArea" class="hidden">
                        <h3 class="font-semibold mt-2 mb-1 text-gray-700">✍️ Pizarra:</h3>
                        <div class="flex flex-col p-2 mb-2 bg-gray-50 rounded-lg border">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center space-x-2"><span class="text-sm font-medium text-gray-700">Pincel:</span><input type="color" id="colorPicker" value="#000000" oninput="setStrokeColor(this.value)"></div>
                                <div class="flex items-center space-x-2"><span class="text-sm font-medium text-gray-700 whitespace-nowrap">Grosor:</span><input type="range" min="2" max="20" value="4" id="strokeWidth" oninput="setStrokeWidth(this.value)" class="w-20"></div>
                            </div>
                            <div class="flex gap-2 pt-2 border-t border-gray-200">
                                <button onclick="setStrokeColor(document.getElementById('colorPicker').value)" class="bg-gray-200 hover:bg-gray-300 text-xs font-bold py-1 px-2 rounded-lg transition">Pincel</button>
                                <button onclick="setEraserMode()" class="flex-grow bg-yellow-100 text-gray-800 font-bold py-1 px-3 rounded-lg border border-yellow-300 hover:bg-yellow-200">🧼 Borrador</button>
                                <button onclick="undoLastAction()" class="bg-indigo-300 hover:bg-indigo-400 text-white font-bold py-1 px-3 rounded-lg flex items-center justify-center"><span class="text-lg leading-none mr-1">&#x21BA;</span> Deshacer</button>
                                <button onclick="clearCanvas()" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg">Borrar Todo</button>
                            </div>
                        </div>
                        <canvas id="drawingCanvas" width="400" height="250" class="w-full rounded-lg mb-2"></canvas>
                        <div class="flex gap-2 mb-4"><button onclick="sendDrawing()" class="flex-grow bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 rounded-lg">Compartir Dibujo</button></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para Zoom de Imagen con Fondo -->
    <div id="imageZoomModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50 hidden" onclick="hideImageZoom()">
        <img id="zoomedImage" src="" class="max-w-full max-h-full rounded-lg shadow-2xl bg-white p-1"> <!-- FONDO BLANCO AÑADIDO -->
        <button onclick="hideImageZoom()" class="absolute top-5 right-5 text-white text-5xl font-bold leading-none">&times;</button>
    </div>

    <!-- Modal para Confirmación de Eliminación (Custom Alert) -->
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full">
            <h4 class="text-xl font-bold mb-4 text-red-600" id="confirmTitle">Confirmar Acción</h4>
            <p class="mb-6 text-gray-700" id="confirmMessage"></p>
            <div class="flex justify-end space-x-3">
                <button onclick="cancelConfirm()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition">Cancelar</button>
                <button onclick="executeConfirm()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition" id="confirmExecuteBtn">Eliminar</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, setLogLevel, getDocs, where, doc, setDoc, updateDoc, arrayUnion, arrayRemove, getDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // ***************************************************************************************************
        // CONFIGURACIÓN DE FIREBASE (Configuración fija del usuario)
        // Ya que Canvas está desactivado, usamos la configuración estática.
        // ***************************************************************************************************
        const firebaseConfig = {
            apiKey: "AIzaSyDz29nVG7QlF7_XbJuDTk3LUZG8yI1MZZc",
            authDomain: "chat-interactivo-143cf.firebaseapp.com",
            projectId: "chat-interactivo-143cf",
            storageBucket: "chat-interactivo-143cf.firebasestorage.app",
            messagingSenderId: "578717210997",
            appId: "1:578717210997:web:959e1a48ea7f39c1da9b3c"
        };
        
        // Usamos el ID del proyecto como ID base para las colecciones (ya que no hay __app_id)
        const APP_ID = firebaseConfig.projectId; 
        
        let db, auth, currentUserId = 'unknown', currentUsername = 'Usuario Anónimo', userMap = {};
        let currentChatPartnerId = null, lastSnapshot = null;
        
        // Rutas de colección adaptadas para uso fuera de Canvas pero con el projectId como base
        const CHAT_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/chat_messages`;
        const USER_PROFILES_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/user_profiles`;
        const BROADCAST_ID = 'broadcast';

        // DOM Elements (referencias)
        const chatMessages = document.getElementById('chatMessages'), messageInput = document.getElementById('messageInput');
        const userInfoDisplay = document.getElementById('userInfo'), userIdShort = document.getElementById('userIdShort');
        const usernameSetup = document.getElementById('usernameSetup'), usernameInput = document.getElementById('usernameInput');
        const usernameError = document.getElementById('usernameError'), usernameDisplay = document.getElementById('usernameDisplay');
        const drawingCanvas = document.getElementById('drawingCanvas'), d_ctx = drawingCanvas.getContext('2d');
        const strokeWidthInput = document.getElementById('strokeWidth'), colorPicker = document.getElementById('colorPicker');
        const chatListView = document.getElementById('chat-list-view'), chatMessagesView = document.getElementById('chat-messages-view');
        const currentChatTitle = document.getElementById('currentChatTitle');
        const imageZoomModal = document.getElementById('imageZoomModal'), zoomedImage = document.getElementById('zoomedImage');
        const confirmModal = document.getElementById('confirmModal'), confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage'), confirmExecuteBtn = document.getElementById('confirmExecuteBtn');
        
        let isDrawing = false, hasDrawn = false, currentColor = '#000000', currentWidth = 4;
        let drawingHistory = [], MAX_HISTORY = 15;
        const AVAILABLE_REACTIONS = ['❤️', '😂', '😢', '😮'];
        let confirmAction = { type: null, payload: null }; // Para manejar la acción de confirmación

        async function initFirebase() {
            try {
                // setLogLevel('debug'); // Desactivado para un entorno de producción/local
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Fuera de Canvas, forzamos la autenticación anónima, ya que no hay token
                await signInAnonymously(auth); 
                
                onAuthStateChanged(auth, user => {
                    if (user) {
                        currentUserId = user.uid;
                        // Mostrar solo los primeros 12 caracteres del ID en modo no-Canvas
                        userIdShort.textContent = currentUserId.substring(0, 12) + '...'; 
                        setupProfileListener();
                        setupMessageListener();
                    } else userInfoDisplay.textContent = `Authentication Error.`;
                });
            } catch (error) { 
                console.error("Firebase Init/Auth Error:", error); 
                userInfoDisplay.textContent = `Error: ${error.message}`; 
            }
        }
        
        window.showUsernameSetup = () => {
            usernameInput.value = (currentUsername !== 'Usuario Anónimo') ? currentUsername : '';
            usernameDisplay.classList.add('hidden');
            usernameSetup.classList.remove('hidden');
        }

        window.attemptSetUsername = async () => {
            const username = usernameInput.value.trim();
            usernameError.classList.add('hidden');
            if (username.length < 3 || !/^[a-zA-Z0-9]+$/.test(username)) {
                usernameError.textContent = "El nombre debe tener 3+ letras/números, sin espacios.";
                usernameError.classList.remove('hidden'); return;
            }
            if (username === currentUsername) { usernameSetup.classList.add('hidden'); usernameDisplay.classList.remove('hidden'); return; }
            try {
                // Chequeo de unicidad del nombre de usuario
                const q = query(collection(db, USER_PROFILES_COLLECTION_PATH), where("username", "==", username));
                const snapshot = await getDocs(q);
                if (!snapshot.empty && snapshot.docs.some(doc => doc.id !== currentUserId)) {
                    usernameError.textContent = `El nombre '${username}' ya está en uso.`;
                    usernameError.classList.remove('hidden'); return;
                }
                
                // Guardar perfil de usuario
                await setDoc(doc(db, USER_PROFILES_COLLECTION_PATH, currentUserId), { userId: currentUserId, username: username, timestamp: serverTimestamp() });
            } catch (e) { 
                console.error("Error setting username:", e); 
                usernameError.textContent = "Error al guardar. Inténtalo de nuevo. Asegúrate de que las Reglas de Seguridad de Firestore permiten escritura pública en 'user_profiles'."; 
                usernameError.classList.remove('hidden'); 
            }
        }
        
        function renderChatList() {
            chatListView.innerHTML = '';
            
            const createChatItem = (id, icon, name, subtext, isDeletable = false) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'flex items-center justify-between p-3 hover:bg-gray-100 rounded-lg cursor-pointer transition-colors border-b last:border-b-0';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex items-center flex-grow min-w-0';
                infoDiv.onclick = () => openChat(id);
                infoDiv.innerHTML = `<div class="w-10 h-10 bg-indigo-500 text-white rounded-full flex items-center justify-center text-xl mr-3">${icon}</div>
                                     <div class="min-w-0 flex-grow">
                                        <h4 class="font-bold text-gray-800 truncate">${name}</h4>
                                        <p class="text-xs text-gray-500 truncate">${subtext}</p>
                                     </div>`;
                itemDiv.appendChild(infoDiv);

                if (isDeletable) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'flex-shrink-0 ml-3 text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition';
                    deleteBtn.textContent = '🗑️';
                    deleteBtn.title = `Eliminar historial con ${name} (la burbuja de chat permanecerá)`;
                    deleteBtn.onclick = (e) => { 
                        e.stopPropagation(); 
                        showConfirm('private_chat', id, name);
                    };
                    itemDiv.appendChild(deleteBtn);
                }
                
                chatListView.appendChild(itemDiv);
            };

            createChatItem('public', '💬', 'Chat General', 'Habla con todos los usuarios');

            Object.keys(userMap).forEach(userId => {
                if(userId !== currentUserId) createChatItem(userId, '👤', userMap[userId], 'Conversación privada', true);
            });
            
            // Botón para eliminar todo el historial de chat general
            const deleteAllPublicBtn = document.createElement('button');
            deleteAllPublicBtn.className = 'w-full mt-4 bg-red-100 text-red-700 border border-red-300 hover:bg-red-200 font-bold py-2 rounded-lg transition';
            deleteAllPublicBtn.textContent = '🗑️ Eliminar Historial de Chat General (Solo mensajes públicos)';
            deleteAllPublicBtn.onclick = () => showConfirm('global_chat_public', null, 'el historial de mensajes públicos');
            chatListView.appendChild(deleteAllPublicBtn);

            // Botón para eliminar el perfil de usuario (opcional)
            const deleteProfileBtn = document.createElement('button');
            deleteProfileBtn.className = 'w-full mt-2 bg-gray-200 text-gray-700 border border-gray-400 hover:bg-gray-300 font-bold py-2 rounded-lg transition';
            deleteProfileBtn.textContent = '❌ Eliminar PERFIL de Usuario (Admin)';
            deleteProfileBtn.onclick = () => showConfirm('user_profile', null, 'un perfil de usuario (se requiere ID)');
            chatListView.appendChild(deleteProfileBtn);
        }

        function setupProfileListener() {
            onSnapshot(collection(db, USER_PROFILES_COLLECTION_PATH), (snapshot) => {
                let userHasProfile = false;
                snapshot.forEach(doc => {
                    const profile = doc.data(); 
                    userMap[profile.userId] = profile.username;
                    if (profile.userId === currentUserId) { userHasProfile = true; currentUsername = profile.username; }
                });
                
                if (currentChatPartnerId === null) renderChatList();
                userInfoDisplay.textContent = `ID: ${currentUserId.substring(0, 8)}...`;
                if (userHasProfile) {
                    usernameSetup.classList.add('hidden');
                    usernameDisplay.textContent = `Chateando como: ${currentUsername} (Click para editar)`;
                    usernameDisplay.classList.remove('hidden');
                    messageInput.placeholder = "Escribe tu mensaje..."; 
                } else {
                    usernameDisplay.classList.add('hidden');
                    usernameSetup.classList.remove('hidden');
                    messageInput.placeholder = "Debes elegir un nombre para chatear..."; 
                }
            });
        }
        
        window.openChat = (partnerId) => {
            currentChatPartnerId = partnerId;
            chatListView.classList.add('hidden');
            chatMessagesView.classList.remove('hidden');
            currentChatTitle.textContent = (partnerId === 'public') ? 'Chat General' : userMap[partnerId] || 'Usuario...';
            if(lastSnapshot) processMessages(lastSnapshot);
        }

        window.showChatList = () => {
            chatListView.classList.remove('hidden');
            chatMessagesView.classList.add('hidden');
            currentChatPartnerId = null;
            renderChatList();
        }

        const sendMessage = async (type, content) => {
            if (currentUsername === 'Usuario Anónimo') {
                postSystemMessage("¡ERROR! Debes configurar un nombre de usuario primero."); return;
            }
            const isPrivate = currentChatPartnerId !== 'public';
            const payload = { userId: currentUserId, type, content, isPrivate, timestamp: serverTimestamp() };
            if (isPrivate) payload.recipientId = currentChatPartnerId;
            if (type === 'drawing') payload.reactions = {}; 
            try { 
                // Asegúrate de que las Reglas de Seguridad permitan esta escritura.
                await addDoc(collection(db, CHAT_COLLECTION_PATH), payload); 
            } 
            catch (e) { 
                console.error(`Error sending ${type}:`, e); 
                postSystemMessage(`ERROR: No se pudo enviar el mensaje. Revisa las Reglas de Seguridad de Firestore. Mensaje: ${e.message}`);
            }
        }

        window.sendChatMessage = () => { const text = messageInput.value.trim(); if (text) { sendMessage('text', text); messageInput.value = ''; } }
        window.sendDrawing = () => { 
            if (currentUsername === 'Usuario Anónimo') {
                postSystemMessage("¡ERROR! Debes configurar un nombre de usuario para compartir dibujos."); return;
            }
            sendMessage('drawing', drawingCanvas.toDataURL()); clearCanvas(); 
        }

        window.sendContextualAlert = async () => {
            if (currentUsername === 'Usuario Anónimo') {
                postSystemMessage("¡ERROR! Debes configurar un nombre de usuario para enviar alertas."); return;
            }
            
            let recipientId;
            let isPrivate = false;

            if (currentChatPartnerId === 'public') {
                recipientId = BROADCAST_ID;
                isPrivate = false; 
            } else if (currentChatPartnerId) {
                recipientId = currentChatPartnerId;
                isPrivate = true;
            } else {
                postSystemMessage("ERROR: No se pudo determinar el destinatario de la alerta.");
                return;
            }

            try { 
                await addDoc(collection(db, CHAT_COLLECTION_PATH), { 
                    userId: currentUserId, 
                    type: 'alert', 
                    recipientId: recipientId, 
                    isPrivate: isPrivate, 
                    timestamp: serverTimestamp() 
                }); 
            } 
            catch (e) { 
                console.error("Error sending contextual alert: ", e); 
                postSystemMessage(`ERROR: No se pudo enviar la alerta. Revisa las Reglas de Seguridad.`);
            }
        }
        
        window.addReaction = async (messageId, emoji) => {
            const messageRef = doc(db, CHAT_COLLECTION_PATH, messageId);
            const docSnap = await getDoc(messageRef);
            if (!docSnap.exists()) return;

            const reactions = docSnap.data().reactions || {};
            const userList = reactions[emoji] || [];
            const userHasReacted = userList.includes(currentUserId);

            const updatePayload = {
                [`reactions.${emoji}`]: userHasReacted ? arrayRemove(currentUserId) : arrayUnion(currentUserId)
            };
            try {
                await updateDoc(messageRef, updatePayload);
            } catch (e) {
                console.error("Error updating reaction:", e);
                postSystemMessage(`ERROR: No se pudo añadir la reacción. Revisa las Reglas de Seguridad.`);
            }
        }

        function renderMessage(doc) {
            const messageId = doc.id;
            const message = doc.data();
            const { userId, type, content, recipientId, reactions } = message;
            const isMe = userId === currentUserId, displayName = userMap[userId] || `Usuario ${userId.substring(0, 6)}`;
            const wrapper = document.createElement('div'), messageDiv = document.createElement('div');
            
            if (type === 'alert') {
                const isBroadcast = recipientId === BROADCAST_ID, targetName = isBroadcast ? 'TODOS' : (userMap[recipientId] || 'alguien');
                const isPrivateAlertToMe = recipientId === currentUserId && !isBroadcast;

                messageDiv.className = `system-message ${isPrivateAlertToMe ? 'bg-orange-100 text-orange-800' : 'bg-yellow-100 text-yellow-800 animate-pulse'}`;

                if (isMe) {
                    messageDiv.textContent = isBroadcast ? `🚨 ALERTA GENERAL enviada.` : `🔔 Alerta enviada a ${targetName}.`;
                } else if (isBroadcast) {
                    messageDiv.textContent = `🚨 ¡ALERTA GENERAL de ${displayName}!`;
                } else if (recipientId === currentUserId) {
                    messageDiv.textContent = `🔔 ¡${displayName} te ha enviado una ALERTA!`;
                } else {
                    messageDiv.textContent = `Alerta enviada por ${displayName}.`;
                }

                wrapper.className = 'w-full';
                wrapper.appendChild(messageDiv);
            } else {
                wrapper.className = `flex flex-col mb-2 ${isMe ? 'items-end' : 'items-start'}`;
                const header = document.createElement('div');
                header.textContent = isMe ? "Tú" : displayName;
                header.className = `font-bold text-xs mb-1 ${isMe ? 'text-indigo-700' : 'text-gray-700'}`;
                messageDiv.className = 'p-3 rounded-xl max-w-xs shadow-md break-words';
                
                if (type === 'text') {
                    messageDiv.className += isMe ? ' bg-indigo-600 text-white ml-auto' : ' bg-gray-200 text-gray-800 mr-auto';
                    messageDiv.textContent = content;
                } else if (type === 'drawing') {
                    messageDiv.className += isMe ? ' ml-auto' : ' mr-auto';
                    const img = document.createElement('img');
                    img.src = content; img.className = 'w-48 h-auto rounded-lg cursor-pointer';
                    img.onclick = () => showImageZoom(content);
                    messageDiv.appendChild(img);

                    const reactionsContainer = document.createElement('div');
                    reactionsContainer.className = 'flex items-center justify-between mt-2';
                    
                    const reactionsDisplay = document.createElement('div');
                    reactionsDisplay.className = 'flex items-center space-x-2';
                    if (reactions) {
                        Object.entries(reactions).forEach(([emoji, users]) => {
                            if (users && users.length > 0) {
                                const reactionBadge = document.createElement('span');
                                reactionBadge.className = 'bg-gray-200 text-gray-700 text-xs px-2 py-1 rounded-full';
                                reactionBadge.textContent = `${emoji} ${users.length}`;
                                reactionsDisplay.appendChild(reactionBadge);
                            }
                        });
                    }

                    const reactionButtons = document.createElement('div');
                    reactionButtons.className = 'flex space-x-1';
                    AVAILABLE_REACTIONS.forEach(emoji => {
                        const button = document.createElement('button');
                        const userHasReacted = reactions && reactions[emoji] && reactions[emoji].includes(currentUserId);
                        button.className = `p-1 rounded-full text-lg transition-transform transform hover:scale-125 ${userHasReacted ? 'bg-blue-100' : 'hover:bg-gray-200'}`;
                        button.textContent = emoji;
                        button.onclick = () => addReaction(messageId, emoji);
                        reactionButtons.appendChild(button);
                    });

                    reactionsContainer.appendChild(reactionsDisplay);
                    reactionsContainer.appendChild(reactionButtons);
                    messageDiv.appendChild(reactionsContainer);
                }
                wrapper.appendChild(header);
                wrapper.appendChild(messageDiv);
            }
            chatMessages.appendChild(wrapper);
        }

        function processMessages(snapshot) {
            const wasScrolledToBottom = chatMessages.scrollHeight - chatMessages.scrollTop <= chatMessages.clientHeight + 1;
            chatMessages.innerHTML = '';
            snapshot.forEach(doc => {
                const msg = doc.data();
                let shouldDisplay = false;
                
                // Criterio de visualización
                if (msg.type === 'alert') {
                    if (currentChatPartnerId === 'public') {
                        if (msg.recipientId === BROADCAST_ID) shouldDisplay = true;
                    }
                    else {
                        const isSentToPartner = msg.userId === currentUserId && msg.recipientId === currentChatPartnerId;
                        const isReceivedFromPartner = msg.userId === currentChatPartnerId && msg.recipientId === currentUserId;
                        
                        if (isSentToPartner || isReceivedFromPartner) shouldDisplay = true;
                    }

                } else if (currentChatPartnerId === 'public') {
                    if (msg.isPrivate === false) shouldDisplay = true;
                } else {
                    const isChatParticipant = (msg.userId === currentUserId && msg.recipientId === currentChatPartnerId) || (msg.userId === currentChatPartnerId && msg.recipientId === currentUserId);
                    if (isChatParticipant) shouldDisplay = true;
                }
                
                if (shouldDisplay) renderMessage(doc); 
            });
            if (wasScrolledToBottom) chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function setupMessageListener() {
            const messagesQuery = query(collection(db, CHAT_COLLECTION_PATH), orderBy('timestamp', 'asc'));
            onSnapshot(messagesQuery, snapshot => {
                snapshot.docChanges().forEach(change => {
                    const msg = change.doc.data();
                    
                    if (change.type === "added" && msg.userId !== currentUserId) {
                        // Lógica de Sonido:
                        if (msg.type === 'alert') {
                            if (msg.recipientId === BROADCAST_ID || msg.recipientId === currentUserId) playSound();
                        }
                        else {
                            if (msg.recipientId === currentUserId && msg.isPrivate === true) playNotificationSound(); 
                            else if (msg.isPrivate === false) playNotificationSound(); 
                        }
                    }
                });
                lastSnapshot = snapshot;
                if (currentChatPartnerId) processMessages(snapshot);
            }, e => { console.error("Message listener error:", e); postSystemMessage("ERROR: No se pudieron cargar los mensajes. Revisa las Reglas de Seguridad para esta ruta."); });
        }

        // ************************************
        // LÓGICA DE MODERACIÓN Y ELIMINACIÓN
        // ************************************

        function showConfirm(type, payload, name) {
            confirmAction = { type, payload };
            confirmTitle.textContent = `Confirmar Eliminación`;
            confirmModal.classList.remove('hidden');

            if (type === 'private_chat') {
                confirmMessage.innerHTML = `¿Estás seguro de que quieres **eliminar el HISTORIAL de mensajes** entre tú y **${name}**? El perfil de **${name}** permanecerá en tu lista de chats y la conversación **volverá a aparecer si te envían un mensaje.**`;
                confirmExecuteBtn.textContent = 'Eliminar Historial';
            } else if (type === 'global_chat_public') {
                confirmMessage.innerHTML = `¡ADVERTENCIA! ¿Estás seguro de que quieres **eliminar TODOS los mensajes públicos** (Chat General) de la base de datos? Esta acción es **IRREVERSIBLE** para todos.`;
                confirmExecuteBtn.textContent = 'Eliminar MENSAJES PÚBLICOS';
            } else if (type === 'user_profile') {
                confirmMessage.innerHTML = `¿Estás seguro de que quieres **eliminar el PERFIL de un usuario**? Se te pedirá su ID. Esto hará que su burbuja de chat desaparezca de la lista (hasta que vuelva a unirse).`;
                confirmExecuteBtn.textContent = 'Eliminar PERFIL (Admin)';
            }
        }

        window.cancelConfirm = () => {
            confirmModal.classList.add('hidden');
            confirmAction = { type: null, payload: null };
        }

        window.executeConfirm = async () => {
            confirmModal.classList.add('hidden');
            const { type, payload } = confirmAction;

            if (type === 'private_chat') {
                await deleteUserChatHistory(payload, userMap[payload]);
            } else if (type === 'global_chat_public') {
                await deleteGlobalPublicChatHistory();
            } else if (type === 'user_profile') {
                const userIdToDelete = prompt("Ingresa el ID completo del usuario que deseas eliminar (ej: S9nL...):");
                if (userIdToDelete && userIdToDelete.length > 5) {
                    await deleteUserProfile(userIdToDelete);
                } else if (userIdToDelete !== null) {
                    postSystemMessage("ID de usuario no válido.");
                }
            }
            confirmAction = { type: null, payload: null };
        }

        async function deleteUserChatHistory(partnerId, partnerName) {
            try {
                const q1 = query(collection(db, CHAT_COLLECTION_PATH), where("userId", "==", currentUserId), where("recipientId", "==", partnerId), where("isPrivate", "==", true));
                const q2 = query(collection(db, CHAT_COLLECTION_PATH), where("userId", "==", partnerId), where("recipientId", "==", currentUserId), where("isPrivate", "==", true));
                
                const [snapshot1, snapshot2] = await Promise.all([getDocs(q1), getDocs(q2)]);
                
                const batch = writeBatch(db);
                let count = 0;
                
                snapshot1.forEach(doc => { batch.delete(doc.ref); count++; });
                snapshot2.forEach(doc => { batch.delete(doc.ref); count++; });
                
                await batch.commit();
                
                postSystemMessage(`✅ Historial privado con ${partnerName} (${count} mensajes) eliminado. La burbuja de chat permanece, y el historial se reiniciará si te vuelve a escribir.`);
                
                if (currentChatPartnerId === partnerId) {
                    chatMessages.innerHTML = '';
                    postSystemMessage("El historial de esta conversación ha sido borrado.");
                }

                showChatList(); 
            } catch (error) {
                console.error("Error al eliminar el historial privado:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el historial privado con ${partnerName}. Revisa las Reglas de Seguridad de Firestore para operaciones de eliminación.`);
            }
        }
        
        async function deleteGlobalPublicChatHistory() {
            try {
                const q = query(collection(db, CHAT_COLLECTION_PATH), where("isPrivate", "==", false));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    postSystemMessage("No hay mensajes públicos para eliminar.");
                    return;
                }

                const batch = writeBatch(db);
                snapshot.forEach((doc) => { batch.delete(doc.ref); });
                await batch.commit();
                
                postSystemMessage(`✅ ${snapshot.size} mensajes públicos eliminados. El Chat General está limpio.`);
                
                if (currentChatPartnerId === 'public') {
                    chatMessages.innerHTML = '';
                    postSystemMessage("El historial del Chat General ha sido borrado.");
                }

                showChatList();
            } catch (error) {
                console.error("Error al eliminar el historial público:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el historial público. Revisa las Reglas de Seguridad de Firestore para operaciones de eliminación.`);
            }
        }
        
        async function deleteUserProfile(userId) {
             try {
                await deleteDoc(doc(db, USER_PROFILES_COLLECTION_PATH, userId));
                postSystemMessage(`Perfil de usuario (ID: ${userId.substring(0, 6)}) eliminado de la base de datos. Su burbuja de chat desaparecerá para todos.`);
            } catch (error) {
                console.error("Error al eliminar el perfil de usuario:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el perfil. Asegúrate de que el ID es correcto y existe, y que las Reglas de Seguridad lo permiten.`);
            }
        }
        
        function postSystemMessage(message) {
            const wrapper = document.createElement('div');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'system-message';
            messageDiv.textContent = message;
            wrapper.className = 'w-full';
            wrapper.appendChild(messageDiv);
            chatMessages.appendChild(wrapper);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // ************************************
        // LÓGICA DE UI, DIBUJO Y AUDIO
        // ************************************

        window.showImageZoom = (src) => { zoomedImage.src = src; imageZoomModal.classList.remove('hidden'); }
        window.hideImageZoom = () => imageZoomModal.classList.add('hidden');

        function saveState() { drawingHistory.push(drawingCanvas.toDataURL()); if (drawingHistory.length > MAX_HISTORY) drawingHistory.shift(); }
        function restoreState(dataURL) { const img = new Image(); img.onload = () => { d_ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); d_ctx.drawImage(img, 0, 0); }; img.src = dataURL; }
        window.undoLastAction = () => { if (drawingHistory.length > 1) { drawingHistory.pop(); restoreState(drawingHistory[drawingHistory.length - 1]); } else clearCanvas(); }
        window.setStrokeColor = color => { currentColor = color; d_ctx.strokeStyle = currentColor; d_ctx.lineWidth = parseInt(strokeWidthInput.value); }
        window.setEraserMode = () => { d_ctx.strokeStyle = '#FFFFFF'; d_ctx.lineWidth = 12; }
        window.setStrokeWidth = width => { d_ctx.lineWidth = parseInt(width); }
        function resizeCanvas() { 
            // Guarda el contenido antes de redimensionar
            const currentDrawing = drawingHistory.length > 0 ? drawingHistory[drawingHistory.length - 1] : null;

            drawingCanvas.width = document.querySelector('#drawingArea').clientWidth; 
            d_ctx.lineCap = 'round'; 
            setStrokeColor(colorPicker.value); 
            
            // Restaura el contenido después de redimensionar
            if (currentDrawing) restoreState(currentDrawing);
            else saveState(); // Asegura que el historial se inicialice si el canvas está vacío
        }
        window.toggleDrawingArea = () => { 
            const drawingArea = document.getElementById('drawingArea');
            const isHidden = drawingArea.classList.toggle('hidden'); 
            document.getElementById('toggleDrawingBtn').textContent = isHidden ? '✍️ Abrir Pizarra de Dibujo' : '❌ Cerrar Pizarra de Dibujo'; 
            if (!isHidden) {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            } else {
                window.removeEventListener('resize', resizeCanvas);
            }
        }

        const getPos = (c, e) => { const r = c.getBoundingClientRect(); return { x: (e.touches ? e.touches[0].clientX : e.clientX) - r.left, y: (e.touches ? e.touches[0].clientY : e.touches[0].clientY) - r.top }; }
        const startDrawing = e => { isDrawing = true; hasDrawn = false; d_ctx.beginPath(); d_ctx.moveTo(getPos(drawingCanvas, e).x, getPos(drawingCanvas, e).y); e.preventDefault(); }
        const draw = e => { if (!isDrawing) return; hasDrawn = true; d_ctx.lineTo(getPos(drawingCanvas, e).x, getPos(drawingCanvas, e).y); d_ctx.stroke(); e.preventDefault(); }
        const stopDrawing = () => { if (isDrawing && hasDrawn) saveState(); isDrawing = false; }
        ['mousedown', 'touchstart'].forEach(e => drawingCanvas.addEventListener(e, startDrawing));
        ['mousemove', 'touchmove'].forEach(e => drawingCanvas.addEventListener(e, draw));
        ['mouseup', 'mouseout', 'touchend'].forEach(e => drawingCanvas.addEventListener(e, stopDrawing));
        window.clearCanvas = () => { d_ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); drawingHistory = []; saveState(); }
        messageInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendChatMessage(); });
        
        let audioContextStarted = false;
        const alertSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, release: 0.3 } }).toDestination();
        const notificationSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.05 }, volume: -10 }).toDestination();
        
        function startAudioContext() { 
            if (audioContextStarted) return; 
            Tone.start().then(() => { audioContextStarted = true; }).catch(e => console.error("Audio context error:", e)); 
        }
        function playSound() { startAudioContext(); if (audioContextStarted) alertSynth.triggerAttackRelease("C5", "4n", Tone.now()); }
        function playNotificationSound() { startAudioContext(); if (audioContextStarted) notificationSynth.triggerAttackRelease("C3", 0.2, Tone.now()); }

        window.onload = () => { 
            initFirebase(); 
            // Inicializar canvas después de un pequeño retraso para asegurar el DOM
            setTimeout(() => {
                clearCanvas(); 
                resizeCanvas();
            }, 100);
        }
    </script>
</body>
</html>
