<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat con Control de Historial y Moderaci√≥n</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Configuraci√≥n de la fuente Inter y estilos base */
        body { font-family: 'Inter', sans-serif; }
        
        #drawingCanvas {
            border: 2px solid #3b82f6;
            background-color: #ffffff;
            touch-action: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #chatMessages, #chat-list-view {
            height: 65vh; 
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .system-message {
            background-color: #e0f2fe;
            padding: 8px 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            font-size: 0.8rem;
            color: #0c4a6e;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-4 max-w-4xl">
        <header class="mb-6 border-b pb-4">
            <h1 class="text-3xl font-extrabold text-gray-900 flex items-center">
                üí¨ Chat Interactivo
                <span id="userIdShort" class="ml-4 text-xs font-mono bg-gray-200 text-gray-600 px-2 py-1 rounded"></span>
            </h1>
            <p id="userInfo" class="text-sm text-gray-500 mt-1">Cargando...</p>
            <div id="usernameDisplay" class="mt-2 text-sm text-indigo-700 font-semibold cursor-pointer hidden" onclick="showUsernameSetup()"></div>
            <div id="usernameSetup" class="mt-2 hidden">
                <input type="text" id="usernameInput" placeholder="Elige un nombre de usuario (sin espacios)" 
                       class="p-2 border border-gray-300 rounded-l-lg w-56 text-sm focus:ring-indigo-500 focus:border-indigo-500">
                <button onclick="attemptSetUsername()" class="bg-indigo-600 text-white p-2 rounded-r-lg text-sm hover:bg-indigo-700 transition">Establecer</button>
                <p id="usernameError" class="text-red-500 text-xs mt-1 hidden"></p>
            </div>
        </header>

        <div id="chat-list-view" class="bg-white rounded-xl shadow-lg p-4 transition-transform duration-300">
            <h3 class="text-xl font-bold mb-4 border-b pb-2 text-gray-800">Chats Disponibles</h3>
            </div>

        <div id="chat-messages-view" class="hidden bg-white rounded-xl shadow-lg p-4 flex flex-col transition-transform duration-300">
            <div class="flex items-center justify-between mb-4 border-b pb-3">
                <button onclick="showChatList()" class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">
                    ‚Üê Volver a Chats
                </button>
                <h3 id="currentChatTitle" class="text-xl font-bold text-gray-800"></h3>
                <button onclick="sendContextualAlert()" title="Enviar una alerta al chat activo o a todos si es General" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-full text-sm transition">
                    üö® ¬°Alerta!
                </button>
            </div>

            <div id="chatMessages" class="flex-grow overflow-y-auto mb-4 p-2 border rounded-lg bg-gray-50">
                </div>
            
            <div class="flex mb-4">
                <input type="text" id="messageInput" placeholder="Escribe tu mensaje..." class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:ring-indigo-500 focus:border-indigo-500">
                <button onclick="sendChatMessage()" class="bg-indigo-600 text-white p-3 rounded-r-lg hover:bg-indigo-700 transition">
                    Enviar
                </button>
            </div>

            <button onclick="toggleDrawingArea()" id="toggleDrawingBtn" class="w-full bg-gray-200 text-gray-700 border border-gray-300 hover:bg-gray-300 font-bold py-2 mb-4 rounded-lg transition">
                ‚úçÔ∏è Abrir Pizarra de Dibujo
            </button>

            <div id="drawingArea" class="hidden border border-dashed border-gray-300 rounded-lg p-2 mb-4 bg-white shadow-inner">
                <div class="flex justify-between items-center mb-2">
                    <div class="flex space-x-2">
                        <input type="color" id="colorPicker" onchange="setStrokeColor(this.value)" value="#000000" class="w-8 h-8 rounded-full border-2 border-gray-300 cursor-pointer">
                        <input type="range" id="strokeWidth" min="2" max="15" value="4" onchange="setStrokeWidth(this.value)" title="Grosor">
                        <button onclick="setEraserMode()" class="p-1 rounded-lg text-lg hover:bg-gray-200" title="Borrador">üßº</button>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="undoLastAction()" class="p-1 rounded-lg text-lg hover:bg-gray-200" title="Deshacer">‚Ü©Ô∏è</button>
                        <button onclick="clearCanvas()" class="p-1 rounded-lg text-lg hover:bg-gray-200" title="Limpiar">üóëÔ∏è</button>
                        <button onclick="sendDrawing()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-lg transition">
                            üñºÔ∏è Enviar Dibujo
                        </button>
                    </div>
                </div>
                <canvas id="drawingCanvas" class="w-full h-[400px]"></canvas>
            </div>
            
        </div>
    </div>

    <div id="imageZoomModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50" onclick="hideImageZoom()">
        <div class="max-w-4xl max-h-full p-4 bg-white rounded-lg" onclick="event.stopPropagation()">
            <img id="zoomedImage" src="" alt="Dibujo Ampliado" class="max-w-full max-h-full rounded-lg shadow-2xl">
        </div>
    </div>
    
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-96">
            <h4 id="confirmTitle" class="text-xl font-bold mb-3 text-gray-900"></h4>
            <p id="confirmMessage" class="mb-4 text-gray-700 leading-relaxed"></p>
            <div class="flex justify-end space-x-3">
                <button onclick="cancelConfirm()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition">Cancelar</button>
                <button onclick="executeConfirm()" id="confirmExecuteBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition">Eliminar</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, setLogLevel, getDocs, where, doc, setDoc, updateDoc, arrayUnion, arrayRemove, getDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // ***************************************************************************************************
        // CONFIGURACI√ìN DE FIREBASE (Configuraci√≥n fija del usuario)
        // ***************************************************************************************************
        const firebaseConfig = {
            apiKey: "AIzaSyDz29nVG7QlF7_XbJuDTk3LUZG8yI1MZZc",
            authDomain: "chat-interactivo-143cf.firebaseapp.com",
            projectId: "chat-interactivo-143cf",
            storageBucket: "chat-interactivo-143cf.firebasestorage.app",
            messagingSenderId: "578717210997",
            appId: "1:578717210997:web:959e1a48ea7f39c1da9b3c"
        };
        
        const APP_ID = firebaseConfig.projectId; 
        
        let db, auth, currentUserId = 'unknown', currentUsername = 'Usuario An√≥nimo', userMap = {};
        let currentChatPartnerId = null, lastSnapshot = null;
        let chatStateMap = { 
            'public': { unreadCount: 0, lastMessagePreview: 'Empieza a chatear.' } 
        };
        
        const CHAT_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/chat_messages`;
        const USER_PROFILES_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/user_profiles`;
        const BROADCAST_ID = 'broadcast';

        // DOM Elements (referencias)
        const chatMessages = document.getElementById('chatMessages'), messageInput = document.getElementById('messageInput');
        const userInfoDisplay = document.getElementById('userInfo'), userIdShort = document.getElementById('userIdShort');
        const usernameSetup = document.getElementById('usernameSetup'), usernameInput = document.getElementById('usernameInput');
        const usernameError = document.getElementById('usernameError'), usernameDisplay = document.getElementById('usernameDisplay');
        const drawingCanvas = document.getElementById('drawingCanvas'), d_ctx = drawingCanvas.getContext('2d');
        const strokeWidthInput = document.getElementById('strokeWidth'), colorPicker = document.getElementById('colorPicker');
        const chatListView = document.getElementById('chat-list-view'), chatMessagesView = document.getElementById('chat-messages-view');
        const currentChatTitle = document.getElementById('currentChatTitle');
        const imageZoomModal = document.getElementById('imageZoomModal'), zoomedImage = document.getElementById('zoomedImage');
        const confirmModal = document.getElementById('confirmModal'), confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage'), confirmExecuteBtn = document.getElementById('confirmExecuteBtn');
        
        let isDrawing = false, hasDrawn = false, currentColor = '#000000', currentWidth = 4;
        let drawingHistory = [], MAX_HISTORY = 15;
        const AVAILABLE_REACTIONS = ['‚ù§Ô∏è', 'üòÇ', 'üò¢', 'üòÆ'];
        let confirmAction = { type: null, payload: null }; // Para manejar la acci√≥n de confirmaci√≥n

        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await signInAnonymously(auth); 
                
                onAuthStateChanged(auth, user => {
                    if (user) {
                        currentUserId = user.uid;
                        userIdShort.textContent = currentUserId.substring(0, 12) + '...'; 
                        setupProfileListener();
                        setupMessageListener();
                    } else userInfoDisplay.textContent = `Authentication Error.`;
                });
            } catch (error) { 
                console.error("Firebase Init/Auth Error:", error); 
                userInfoDisplay.textContent = `Error: ${error.message}`; 
            }
        }
        
        window.showUsernameSetup = () => {
            usernameInput.value = (currentUsername !== 'Usuario An√≥nimo') ? currentUsername : '';
            usernameDisplay.classList.add('hidden');
            usernameSetup.classList.remove('hidden');
        }

        window.attemptSetUsername = async () => {
            const username = usernameInput.value.trim();
            usernameError.classList.add('hidden');
            if (username.length < 3 || !/^[a-zA-Z0-9]+$/.test(username)) {
                usernameError.textContent = "El nombre debe tener 3+ letras/n√∫meros, sin espacios.";
                usernameError.classList.remove('hidden'); return;
            }
            if (username === currentUsername) { usernameSetup.classList.add('hidden'); usernameDisplay.classList.remove('hidden'); return; }
            try {
                const q = query(collection(db, USER_PROFILES_COLLECTION_PATH), where("username", "==", username));
                const snapshot = await getDocs(q);
                if (!snapshot.empty && snapshot.docs.some(doc => doc.id !== currentUserId)) {
                    usernameError.textContent = `El nombre '${username}' ya est√° en uso.`;
                    usernameError.classList.remove('hidden'); return;
                }
                
                await setDoc(doc(db, USER_PROFILES_COLLECTION_PATH, currentUserId), { userId: currentUserId, username: username, timestamp: serverTimestamp() });
            } catch (e) { 
                console.error("Error setting username:", e); 
                usernameError.textContent = "Error al guardar. Int√©ntalo de nuevo. Aseg√∫rate de que las Reglas de Seguridad de Firestore permiten escritura p√∫blica en 'user_profiles'."; 
                usernameError.classList.remove('hidden'); 
            }
        }
        
        function renderChatList() {
            chatListView.innerHTML = '';
            
            const createChatItem = (id, icon, name, subtext, isDeletable = false) => {
                const itemDiv = document.createElement('div');
                const isUnread = chatStateMap[id] && chatStateMap[id].unreadCount > 0;
                itemDiv.className = `flex items-center justify-between p-3 ${isUnread ? 'bg-indigo-50 border-indigo-200' : 'hover:bg-gray-100 border-gray-200'} rounded-lg cursor-pointer transition-colors border-b last:border-b-0`;
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex items-center flex-grow min-w-0';
                infoDiv.onclick = () => openChat(id);
                infoDiv.innerHTML = `<div class="w-10 h-10 bg-indigo-500 text-white rounded-full flex items-center justify-center text-xl mr-3">${icon}</div>
                                     <div class="min-w-0 flex-grow">
                                        <h4 class="font-bold text-gray-800 truncate">${name}</h4>
                                        <p class="text-xs ${isUnread ? 'text-indigo-700 font-semibold' : 'text-gray-500'} truncate">${chatStateMap[id] ? chatStateMap[id].lastMessagePreview : subtext}</p>
                                     </div>`;
                itemDiv.appendChild(infoDiv);

                const actionContainer = document.createElement('div');
                actionContainer.className = 'flex items-center space-x-2';

                if (isUnread) {
                    const countBadge = document.createElement('span');
                    countBadge.className = 'flex-shrink-0 bg-red-500 text-white text-xs font-bold w-5 h-5 flex items-center justify-center rounded-full';
                    countBadge.textContent = chatStateMap[id].unreadCount;
                    actionContainer.appendChild(countBadge);
                }

                if (isDeletable) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'flex-shrink-0 text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition';
                    deleteBtn.textContent = 'üóëÔ∏è';
                    deleteBtn.title = `Eliminar historial con ${name} (la burbuja de chat permanecer√°)`;
                    deleteBtn.onclick = (e) => { 
                        e.stopPropagation(); 
                        showConfirm('private_chat', id, name);
                    };
                    actionContainer.appendChild(deleteBtn);
                }
                
                itemDiv.appendChild(actionContainer);
                chatListView.appendChild(itemDiv);
            };

            createChatItem('public', 'üí¨', 'Chat General', 'Habla con todos los usuarios');

            Object.keys(userMap).forEach(userId => {
                if (userId !== currentUserId && !chatStateMap[userId]) {
                     chatStateMap[userId] = { unreadCount: 0, lastMessagePreview: 'Sin mensajes.' };
                }
                if(userId !== currentUserId) createChatItem(userId, 'üë§', userMap[userId], 'Conversaci√≥n privada', true);
            });
            
            const deleteAllPublicBtn = document.createElement('button');
            deleteAllPublicBtn.className = 'w-full mt-4 bg-red-100 text-red-700 border border-red-300 hover:bg-red-200 font-bold py-2 rounded-lg transition';
            deleteAllPublicBtn.textContent = 'üóëÔ∏è Eliminar Historial de Chat General (Solo mensajes p√∫blicos)';
            deleteAllPublicBtn.onclick = () => showConfirm('global_chat_public', null, 'el historial de mensajes p√∫blicos');
            chatListView.appendChild(deleteAllPublicBtn);

            const deleteProfileBtn = document.createElement('button');
            deleteProfileBtn.className = 'w-full mt-2 bg-gray-200 text-gray-700 border border-gray-400 hover:bg-gray-300 font-bold py-2 rounded-lg transition';
            deleteProfileBtn.textContent = '‚ùå Eliminar PERFIL de Usuario (Admin)';
            deleteProfileBtn.onclick = () => showConfirm('user_profile', null, 'un perfil de usuario (se requiere ID)');
            chatListView.appendChild(deleteProfileBtn);
        }

        function setupProfileListener() {
            onSnapshot(collection(db, USER_PROFILES_COLLECTION_PATH), (snapshot) => {
                let userHasProfile = false;
                snapshot.forEach(doc => {
                    const profile = doc.data(); 
                    userMap[profile.userId] = profile.username;
                    if (profile.userId === currentUserId) { userHasProfile = true; currentUsername = profile.username; }
                });
                
                if (currentChatPartnerId === null) renderChatList();
                userInfoDisplay.textContent = `ID: ${currentUserId.substring(0, 8)}...`;
                if (userHasProfile) {
                    usernameSetup.classList.add('hidden');
                    usernameDisplay.textContent = `Chateando como: ${currentUsername} (Click para editar)`;
                    usernameDisplay.classList.remove('hidden');
                    messageInput.placeholder = "Escribe tu mensaje..."; 
                } else {
                    usernameDisplay.classList.add('hidden');
                    usernameSetup.classList.remove('hidden');
                    messageInput.placeholder = "Debes elegir un nombre para chatear..."; 
                }
            });
        }
        
        window.openChat = (partnerId) => {
            currentChatPartnerId = partnerId;
            chatListView.classList.add('hidden');
            chatMessagesView.classList.remove('hidden');
            currentChatTitle.textContent = (partnerId === 'public') ? 'Chat General' : userMap[partnerId] || 'Usuario...';
            
            if (chatStateMap[partnerId]) {
                chatStateMap[partnerId].unreadCount = 0;
            }
            
            if(lastSnapshot) processMessages(lastSnapshot);
            renderChatList();
        }

        window.showChatList = () => {
            chatListView.classList.remove('hidden');
            chatMessagesView.classList.add('hidden');
            currentChatPartnerId = null;
            renderChatList();
        }

        const sendMessage = async (type, content) => {
            if (currentUsername === 'Usuario An√≥nimo') {
                postSystemMessage("¬°ERROR! Debes configurar un nombre de usuario primero."); return;
            }
            const isPrivate = currentChatPartnerId !== 'public';
            const payload = { userId: currentUserId, type, content, isPrivate, timestamp: serverTimestamp() };
            if (isPrivate) payload.recipientId = currentChatPartnerId;
            if (type === 'drawing') payload.reactions = {}; 
            try { 
                await addDoc(collection(db, CHAT_COLLECTION_PATH), payload); 
            } 
            catch (e) { 
                console.error(`Error sending ${type}:`, e); 
                postSystemMessage(`ERROR: No se pudo enviar el mensaje. Revisa las Reglas de Seguridad de Firestore. Mensaje: ${e.message}`);
            }
        }

        window.sendChatMessage = () => { const text = messageInput.value.trim(); if (text) { sendMessage('text', text); messageInput.value = ''; } }
        window.sendDrawing = () => { 
            if (currentUsername === 'Usuario An√≥nimo') {
                postSystemMessage("¬°ERROR! Debes configurar un nombre de usuario para compartir dibujos."); return;
            }
            sendMessage('drawing', drawingCanvas.toDataURL()); clearCanvas(); 
        }

        window.sendContextualAlert = async () => {
            if (currentUsername === 'Usuario An√≥nimo') {
                postSystemMessage("¬°ERROR! Debes configurar un nombre de usuario para enviar alertas."); return;
            }
            
            let recipientId;
            let isPrivate = false;

            if (currentChatPartnerId === 'public') {
                recipientId = BROADCAST_ID;
                isPrivate = false; 
            } else if (currentChatPartnerId) {
                recipientId = currentChatPartnerId;
                isPrivate = true;
            } else {
                postSystemMessage("ERROR: No se pudo determinar el destinatario de la alerta.");
                return;
            }

            try { 
                await addDoc(collection(db, CHAT_COLLECTION_PATH), { 
                    userId: currentUserId, 
                    type: 'alert', 
                    recipientId: recipientId, 
                    isPrivate: isPrivate, 
                    timestamp: serverTimestamp() 
                }); 
            } 
            catch (e) { 
                console.error("Error sending contextual alert: ", e); 
                postSystemMessage(`ERROR: No se pudo enviar la alerta. Revisa las Reglas de Seguridad.`);
            }
        }
        
        window.addReaction = async (messageId, emoji) => {
            const messageRef = doc(db, CHAT_COLLECTION_PATH, messageId);
            const docSnap = await getDoc(messageRef);
            if (!docSnap.exists()) return;

            const reactions = docSnap.data().reactions || {};
            const userList = reactions[emoji] || [];
            const userHasReacted = userList.includes(currentUserId);

            const updatePayload = {
                [`reactions.${emoji}`]: userHasReacted ? arrayRemove(currentUserId) : arrayUnion(currentUserId)
            };
            try {
                await updateDoc(messageRef, updatePayload);
            } catch (e) {
                console.error("Error updating reaction:", e);
                postSystemMessage(`ERROR: No se pudo a√±adir la reacci√≥n. Revisa las Reglas de Seguridad.`);
            }
        }

        function renderMessage(doc) {
            const messageId = doc.id;
            const message = doc.data();
            const { userId, type, content, recipientId, reactions } = message;
            const isMe = userId === currentUserId, displayName = userMap[userId] || `Usuario ${userId.substring(0, 6)}`;
            const wrapper = document.createElement('div'), messageDiv = document.createElement('div');
            
            if (type === 'alert') {
                const isBroadcast = recipientId === BROADCAST_ID, targetName = isBroadcast ? 'TODOS' : (userMap[recipientId] || 'alguien');
                const isPrivateAlertToMe = recipientId === currentUserId && !isBroadcast;

                messageDiv.className = `system-message ${isPrivateAlertToMe ? 'bg-orange-100 text-orange-800' : 'bg-yellow-100 text-yellow-800 animate-pulse'}`;

                if (isMe) {
                    messageDiv.textContent = isBroadcast ? `üö® ALERTA GENERAL enviada.` : `üîî Alerta enviada a ${targetName}.`;
                } else if (isBroadcast) {
                    messageDiv.textContent = `üö® ¬°ALERTA GENERAL de ${displayName}!`;
                } else if (recipientId === currentUserId) {
                    messageDiv.textContent = `üîî ¬°${displayName} te ha enviado una ALERTA!`;
                } else {
                    messageDiv.textContent = `Alerta enviada por ${displayName}.`;
                }

                wrapper.className = 'w-full';
                wrapper.appendChild(messageDiv);
            } else {
                wrapper.className = `flex flex-col mb-2 ${isMe ? 'items-end' : 'items-start'}`;
                const header = document.createElement('div');
                header.textContent = isMe ? "T√∫" : displayName;
                header.className = `font-bold text-xs mb-1 ${isMe ? 'text-indigo-700' : 'text-gray-700'}`;
                messageDiv.className = 'p-3 rounded-xl max-w-xs shadow-md break-words';
                
                if (type === 'text') {
                    messageDiv.className += isMe ? ' bg-indigo-600 text-white ml-auto' : ' bg-gray-200 text-gray-800 mr-auto';
                    messageDiv.textContent = content;
                } else if (type === 'drawing') {
                    messageDiv.className += isMe ? ' ml-auto' : ' mr-auto';
                    const img = document.createElement('img');
                    img.src = content; img.className = 'w-48 h-auto rounded-lg cursor-pointer';
                    img.onclick = () => showImageZoom(content);
                    messageDiv.appendChild(img);

                    const reactionsContainer = document.createElement('div');
                    reactionsContainer.className = 'flex items-center justify-between mt-2';
                    
                    const reactionsDisplay = document.createElement('div');
                    reactionsDisplay.className = 'flex items-center space-x-2';
                    if (reactions) {
                        Object.entries(reactions).forEach(([emoji, users]) => {
                            if (users && users.length > 0) {
                                const reactionBadge = document.createElement('span');
                                reactionBadge.className = 'bg-gray-200 text-gray-700 text-xs px-2 py-1 rounded-full';
                                reactionBadge.textContent = `${emoji} ${users.length}`;
                                reactionsDisplay.appendChild(reactionBadge);
                            }
                        });
                    }

                    const reactionButtons = document.createElement('div');
                    reactionButtons.className = 'flex space-x-1';
                    AVAILABLE_REACTIONS.forEach(emoji => {
                        const button = document.createElement('button');
                        const userHasReacted = reactions && reactions[emoji] && reactions[emoji].includes(currentUserId);
                        button.className = `p-1 rounded-full text-lg transition-transform transform hover:scale-125 ${userHasReacted ? 'bg-blue-100' : 'hover:bg-gray-200'}`;
                        button.textContent = emoji;
                        button.onclick = () => addReaction(messageId, emoji);
                        reactionButtons.appendChild(button);
                    });

                    reactionsContainer.appendChild(reactionsDisplay);
                    reactionsContainer.appendChild(reactionButtons);
                    messageDiv.appendChild(reactionsContainer);
                }
                wrapper.appendChild(header);
                wrapper.appendChild(messageDiv);
            }
            chatMessages.appendChild(wrapper);
        }

        function processMessages(snapshot) {
            const wasScrolledToBottom = chatMessages.scrollHeight - chatMessages.scrollTop <= chatMessages.clientHeight + 1;
            chatMessages.innerHTML = '';
            snapshot.forEach(doc => {
                const msg = doc.data();
                let shouldDisplay = false;
                
                if (msg.type === 'alert') {
                    if (currentChatPartnerId === 'public') {
                        if (msg.recipientId === BROADCAST_ID) shouldDisplay = true;
                    }
                    else {
                        const isSentToPartner = msg.userId === currentUserId && msg.recipientId === currentChatPartnerId;
                        const isReceivedFromPartner = msg.userId === currentChatPartnerId && msg.recipientId === currentUserId;
                        
                        if (isSentToPartner || isReceivedFromPartner) shouldDisplay = true;
                    }

                } else if (currentChatPartnerId === 'public') {
                    if (msg.isPrivate === false) shouldDisplay = true;
                } else {
                    const isChatParticipant = (msg.userId === currentUserId && msg.recipientId === currentChatPartnerId) || (msg.userId === currentChatPartnerId && msg.recipientId === currentUserId);
                    if (isChatParticipant) shouldDisplay = true;
                }
                
                if (shouldDisplay) renderMessage(doc); 
            });
            if (wasScrolledToBottom) chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function getMessagePreview(msg) {
            if (msg.type === 'text') return msg.content.substring(0, 30) + (msg.content.length > 30 ? '...' : '');
            if (msg.type === 'drawing') return 'üñºÔ∏è Dibujo compartido';
            if (msg.type === 'alert') {
                if (msg.recipientId === BROADCAST_ID) return 'üö® Alerta General';
                if (msg.recipientId === currentUserId) return 'üîî ¬°Alerta Privada!';
            }
            return 'Mensaje de sistema/desconocido';
        }


        function setupMessageListener() {
            const messagesQuery = query(collection(db, CHAT_COLLECTION_PATH), orderBy('timestamp', 'asc'));
            onSnapshot(messagesQuery, snapshot => {
                let needsChatListUpdate = false;

                snapshot.docChanges().forEach(change => {
                    const msg = change.doc.data();
                    
                    if (change.type === "added") {
                        const senderId = msg.userId;
                        const isMe = senderId === currentUserId;
                        
                        let targetId = null; 
                        if (msg.isPrivate === false) {
                            targetId = 'public';
                        } else if (msg.isPrivate === true) {
                            targetId = isMe ? msg.recipientId : senderId;
                        }
                        
                        if (targetId) {
                            if (!chatStateMap[targetId]) {
                                chatStateMap[targetId] = { unreadCount: 0, lastMessagePreview: 'Sin mensajes.' };
                            }
                            
                            const senderName = userMap[senderId] || senderId.substring(0, 6);
                            let preview = getMessagePreview(msg);
                            if (targetId === 'public') {
                                preview = `${isMe ? 'T√∫' : senderName}: ${preview}`;
                            } else if (isMe) {
                                preview = `T√∫: ${preview}`;
                            } 
                            chatStateMap[targetId].lastMessagePreview = preview;

                            if (!isMe && targetId !== currentChatPartnerId) {
                                chatStateMap[targetId].unreadCount++;
                                needsChatListUpdate = true;
                            } else if (targetId === currentChatPartnerId) {
                                chatStateMap[targetId].unreadCount = 0;
                            }

                            if (!isMe) {
                                if (msg.type === 'alert') {
                                    if (msg.recipientId === BROADCAST_ID || msg.recipientId === currentUserId) playAlertSound();
                                }
                                else {
                                    if (msg.isPrivate === true && msg.recipientId === currentUserId) playNotificationSound();
                                    else if (msg.isPrivate === false && targetId === 'public') playNotificationSound();
                                }
                            }
                        }
                    }
                });
                
                lastSnapshot = snapshot;

                if (currentChatPartnerId) {
                    processMessages(snapshot);
                }
                
                if (needsChatListUpdate || currentChatPartnerId === null) {
                    renderChatList();
                }

            }, e => { console.error("Message listener error:", e); postSystemMessage("ERROR: No se pudieron cargar los mensajes. Revisa las Reglas de Seguridad para esta ruta."); });
        }

        // ************************************
        // L√ìGICA DE MODERACI√ìN Y ELIMINACI√ìN
        // ************************************

        function showConfirm(type, payload, name) {
            confirmAction = { type, payload };
            confirmTitle.textContent = `Confirmar Eliminaci√≥n`;
            confirmModal.classList.remove('hidden');

            if (type === 'private_chat') {
                confirmMessage.innerHTML = `¬øEst√°s seguro de que quieres **eliminar el HISTORIAL de mensajes** entre t√∫ y **${name}**? El perfil de **${name}** permanecer√° en tu lista de chats y la conversaci√≥n **volver√° a aparecer si te env√≠an un mensaje.**`;
                confirmExecuteBtn.textContent = 'Eliminar Historial';
            } else if (type === 'global_chat_public') {
                confirmMessage.innerHTML = `¬°ADVERTENCIA! ¬øEst√°s seguro de que quieres **eliminar TODOS los mensajes p√∫blicos** (Chat General) de la base de datos? Esta acci√≥n es **IRREVERSIBLE** para todos.`;
                confirmExecuteBtn.textContent = 'Eliminar MENSAJES P√öBLICOS';
            } else if (type === 'user_profile') {
                confirmMessage.innerHTML = `¬øEst√°s seguro de que quieres **eliminar el PERFIL de un usuario**? Se te pedir√° su ID. Esto har√° que su burbuja de chat desaparezca de la lista (hasta que vuelva a unirse).`;
                confirmExecuteBtn.textContent = 'Eliminar PERFIL (Admin)';
            }
        }

        window.cancelConfirm = () => {
            confirmModal.classList.add('hidden');
            confirmAction = { type: null, payload: null };
        }

        window.executeConfirm = async () => {
            confirmModal.classList.add('hidden');
            const { type, payload } = confirmAction;

            if (type === 'private_chat') {
                await deleteUserChatHistory(payload, userMap[payload]);
            } else if (type === 'global_chat_public') {
                await deleteGlobalPublicChatHistory();
            } else if (type === 'user_profile') {
                const userIdToDelete = prompt("Ingresa el ID completo del usuario que deseas eliminar (ej: S9nL...):");
                if (userIdToDelete && userIdToDelete.length > 5) {
                    await deleteUserProfile(userIdToDelete);
                } else if (userIdToDelete !== null) {
                    postSystemMessage("ID de usuario no v√°lido.");
                }
            }
            confirmAction = { type: null, payload: null };
        }

        async function deleteUserChatHistory(partnerId, partnerName) {
            try {
                const q1 = query(collection(db, CHAT_COLLECTION_PATH), where("userId", "==", currentUserId), where("recipientId", "==", partnerId), where("isPrivate", "==", true));
                const q2 = query(collection(db, CHAT_COLLECTION_PATH), where("userId", "==", partnerId), where("recipientId", "==", currentUserId), where("isPrivate", "==", true));
                
                const [snapshot1, snapshot2] = await Promise.all([getDocs(q1), getDocs(q2)]);
                
                const batch = writeBatch(db);
                let count = 0;
                
                snapshot1.forEach(doc => { batch.delete(doc.ref); count++; });
                snapshot2.forEach(doc => { batch.delete(doc.ref); count++; });
                
                await batch.commit();
                
                postSystemMessage(`‚úÖ Historial privado con ${partnerName} (${count} mensajes) eliminado. La burbuja de chat permanece, y el historial se reiniciar√° si te vuelve a escribir.`);
                
                if (currentChatPartnerId === partnerId) {
                    chatMessages.innerHTML = '';
                    postSystemMessage("El historial de esta conversaci√≥n ha sido borrado.");
                }
                
                if (chatStateMap[partnerId]) {
                    chatStateMap[partnerId].unreadCount = 0;
                    chatStateMap[partnerId].lastMessagePreview = 'Historial borrado. Empieza una nueva conversaci√≥n.';
                }

                showChatList(); 
            } catch (error) {
                console.error("Error al eliminar el historial privado:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el historial privado con ${partnerName}. Revisa las Reglas de Seguridad de Firestore para operaciones de eliminaci√≥n.`);
            }
        }
        
        async function deleteGlobalPublicChatHistory() {
            try {
                const q = query(collection(db, CHAT_COLLECTION_PATH), where("isPrivate", "==", false));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    postSystemMessage("No hay mensajes p√∫blicos para eliminar.");
                    return;
                }

                const batch = writeBatch(db);
                snapshot.forEach((doc) => { batch.delete(doc.ref); });
                await batch.commit();
                
                postSystemMessage(`‚úÖ ${snapshot.size} mensajes p√∫blicos eliminados. El Chat General est√° limpio.`);
                
                if (chatStateMap['public']) {
                    chatStateMap['public'].unreadCount = 0;
                    chatStateMap['public'].lastMessagePreview = 'Historial borrado. Empieza a chatear.';
                }
                
                if (currentChatPartnerId === 'public') {
                    chatMessages.innerHTML = '';
                    postSystemMessage("El historial del Chat General ha sido borrado.");
                }

                showChatList();
            } catch (error) {
                console.error("Error al eliminar el historial p√∫blico:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el historial p√∫blico. Revisa las Reglas de Seguridad de Firestore para operaciones de eliminaci√≥n.`);
            }
        }
        
        async function deleteUserProfile(userId) {
             try {
                await deleteDoc(doc(db, USER_PROFILES_COLLECTION_PATH, userId));
                postSystemMessage(`Perfil de usuario (ID: ${userId.substring(0, 6)}) eliminado de la base de datos. Su burbuja de chat desaparecer√° para todos.`);
                
                delete chatStateMap[userId];

            } catch (error) {
                console.error("Error al eliminar el perfil de usuario:", error);
                postSystemMessage(`ERROR: No se pudo eliminar el perfil. Aseg√∫rate de que el ID es correcto y existe, y que las Reglas de Seguridad lo permiten.`);
            }
        }
        
        function postSystemMessage(message) {
            const wrapper = document.createElement('div');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'system-message';
            messageDiv.textContent = message;
            wrapper.className = 'w-full';
            wrapper.appendChild(messageDiv);
            chatMessages.appendChild(wrapper);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // ************************************
        // L√ìGICA DE UI, DIBUJO Y AUDIO
        // ************************************

        window.showImageZoom = (src) => { zoomedImage.src = src; imageZoomModal.classList.remove('hidden'); }
        window.hideImageZoom = () => imageZoomModal.classList.add('hidden');

        function saveState() { drawingHistory.push(drawingCanvas.toDataURL()); if (drawingHistory.length > MAX_HISTORY) drawingHistory.shift(); }
        function restoreState(dataURL) { const img = new Image(); img.onload = () => { d_ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); d_ctx.drawImage(img, 0, 0); }; img.src = dataURL; }
        window.undoLastAction = () => { if (drawingHistory.length > 1) { drawingHistory.pop(); restoreState(drawingHistory[drawingHistory.length - 1]); } else clearCanvas(); }
        window.setStrokeColor = color => { currentColor = color; d_ctx.strokeStyle = currentColor; d_ctx.lineWidth = parseInt(strokeWidthInput.value); }
        window.setEraserMode = () => { d_ctx.strokeStyle = '#FFFFFF'; d_ctx.lineWidth = 12; }
        window.setStrokeWidth = width => { d_ctx.lineWidth = parseInt(width); }
        function resizeCanvas() { 
            // Guarda el contenido antes de redimensionar
            const currentDrawing = drawingHistory.length > 0 ? drawingHistory[drawingHistory.length - 1] : null;

            // Establecer la altura y el ancho f√≠sico del canvas.
            const drawingArea = document.querySelector('#drawingArea');
            drawingCanvas.width = drawingArea.clientWidth; 
            // CAMBIO: Altura fijada a 400px (para el aspecto cuadrado/alto)
            drawingCanvas.height = 400; 

            d_ctx.lineCap = 'round'; 
            setStrokeColor(colorPicker.value); 
            
            // Restaura el contenido despu√©s de redimensionar
            if (currentDrawing) restoreState(currentDrawing);
            else saveState();
        }
        window.toggleDrawingArea = () => { 
            const drawingArea = document.getElementById('drawingArea');
            const isHidden = drawingArea.classList.toggle('hidden'); 
            document.getElementById('toggleDrawingBtn').textContent = isHidden ? '‚úçÔ∏è Abrir Pizarra de Dibujo' : '‚ùå Cerrar Pizarra de Dibujo'; 
            if (!isHidden) {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            } else {
                window.removeEventListener('resize', resizeCanvas);
            }
        }

        // FIX CR√çTICO: Se corrigi√≥ la l√≥gica del rat√≥n para que use e.clientX/Y cuando e.touches es nulo.
        const getPos = (c, e) => { 
            const r = c.getBoundingClientRect(); 
            return { 
                x: (e.touches ? e.touches[0].clientX : e.clientX) - r.left, 
                y: (e.touches ? e.touches[0].clientY : e.clientY) - r.top 
            }; 
        }

        const startDrawing = e => { isDrawing = true; hasDrawn = false; d_ctx.beginPath(); d_ctx.moveTo(getPos(drawingCanvas, e).x, getPos(drawingCanvas, e).y); e.preventDefault(); }
        const draw = e => { if (!isDrawing) return; hasDrawn = true; d_ctx.lineTo(getPos(drawingCanvas, e).x, getPos(drawingCanvas, e).y); d_ctx.stroke(); e.preventDefault(); }
        const stopDrawing = () => { if (isDrawing && hasDrawn) saveState(); isDrawing = false; }
        ['mousedown', 'touchstart'].forEach(e => drawingCanvas.addEventListener(e, startDrawing));
        ['mousemove', 'touchmove'].forEach(e => drawingCanvas.addEventListener(e, draw));
        ['mouseup', 'mouseout', 'touchend'].forEach(e => drawingCanvas.addEventListener(e, stopDrawing));
        window.clearCanvas = () => { d_ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); drawingHistory = []; saveState(); }
        messageInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendChatMessage(); });
        
        let audioContextStarted = false;
        const alertSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, release: 0.3 }, volume: -5 }).toDestination();
        const notificationSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.05 }, volume: -2 }).toDestination();
        
        function startAudioContext() { 
            if (audioContextStarted) return; 
            Tone.start().then(() => { audioContextStarted = true; }).catch(e => console.error("Audio context error:", e)); 
        }
        function playAlertSound() { startAudioContext(); if (audioContextStarted) alertSynth.triggerAttackRelease("C5", "4n", Tone.now()); }
        function playNotificationSound() { startAudioContext(); if (audioContextStarted) notificationSynth.triggerAttackRelease("C3", 0.2, Tone.now()); }

        window.onload = () => { 
            initFirebase(); 
            // Inicializar canvas despu√©s de un peque√±o retraso para asegurar el DOM
            setTimeout(() => {
                clearCanvas(); 
                resizeCanvas();
            }, 100);
        }
    </script>
</body>
</html>